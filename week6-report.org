* 2016-March-28-Monday:
** From 9:30 AM TO 06:00 PM :
 - Today I took various web-servers such as DHCP-Server, BIND(DNS)-Server and I installed DHCP and BIND(DNS) Servers on CentOS. I have read about those servers and taken various articles from online.
* DHCP(Dynamic Host Configuration Protocol):
 - Dynamic Host Configuration Protocol (DHCP) is a network protocol that automatically assigns TCP/IP information to client machines.
   Each DHCP client connects to the centrally located DHCP server, which returns the network configuration (including the IP address, gateway, and DNS servers)
   of that client. 
** Why use DHCP ?
 - DHCP is useful for automatic configuration of client network interfaces. When configuring the client system, you can choose DHCP instead of specifying an 
   IP address, netmask, gateway, or DNS servers. The client retrieves this information from the DHCP server. DHCP is also useful if you want to change the
   IP addresses of a large number of systems. Instead of reconfiguring all the systems, you can just edit one configuration file on the server for the new set of IP addresses.
   If the DNS servers for an organization changes, the changes happen on the DHCP server, not on the DHCP clients. When you restart the network or reboot the clients,
   the changes go into effect.
 - If an organization has a functional DHCP server correctly connected to a network, laptops and other mobile computer users can move these devices from office to office. 
** Advantages of DHCP-Server:
 - There is no need to manually configure each client with an IP address.
 - You don't need to keep a record of the IP addresses that you have assigned.
 - You can automatically assign a new IP address if you move a client to a different subnet.
* Installing DHCP server on Centos:
- Update yum repositories and packages by typing the below command
#+begin_example
[root@localhost ~]# yum update
#+end_example
- Install dhcp server and client using the below command
#+begin_example
[root@localhost ~]# yum install dhcp
#+end_example
* DNS-Server 
- Domain Name System (or Service or Server), an Internet service that translates domain names into IP addresses. Because domain names are alphabetic,
  they're easier to remember. The Internet however, is really based on IP addresses. Every time you use a domain name, therefore,
  a DNS service must translate the name into the corresponding IP address.
   * EX:= To find the IP address of www.example.com. We use command as below
#+begin_example
nslookup www.example.com
#+end_example
The above command will give the ip address associated with =www.example.com= using DNS server.
* BIND(DNS)-Sever:
- BIND stands for Berkley Internet Naming Daemon. Which is the most common program used for maintaining a name server on Linux.
** Advantages of DNS-Server:
- DNS can be configured to allow dynamic secure updates, enhancing the security of your DNS infrastructure.
- No need to memorise numbers.
- Domain names makes / gives a kind of sense to hyper links when a name is given instead of a string of numbers .
- Easy for categorising,archiving and inturn helping ( to an extent ) search engines.
* Installing BIND on DNS Servers:
- Update yum repositories and packages by typing the below command
#+begin_example
[root@localhost ~]# yum update
#+end_example
- Install BIND(DNS) Server using the below command
#+begin_example
[root@masterdns ~]# yum install bind* -y
#+end_example


* 2016-March-29-Tuesday:
** From 9:30 AM TO 05:30 PM :
 - Today I took setup DHCP server and Installed DHCP server on CentOS. I have read about DHCP server and taken various articles from online is available at [[http://www.krizna.com/centos/install-configure-dhcp-server-centos-6/][here]]
* Setup DHCP server on Centos:
- Dynamic Host Configuration Protocol (DHCP) is used to assign IP addresses and other stuff like gateway and DNS details automatically to the clients.
  we need a DHCP server configured for offering ipaddress to the clients when it is required.
* Installing DHCP server on Centos:
- Update yum repositories and packages by typing the below command
#+begin_example
[root@localhost ~]# yum update
#+end_example
- *Step 1* » Install dhcp server and client using the below command
#+begin_example
[root@localhost ~]# yum install dhcp
#+end_example
- *Step 2* » After installing dhcp server packages along with dependencies .Assign a static ip (eg: “192.168.1.11”) in the same DHCP range for
  the listening interface ( eg : “eth0” ). Open =/etc/sysconfig/network-scripts/ifcfg-eth0= file and make the changes as per your requirement .
#+begin_example
HWADDR="00:0C:29:F1:01:4B"
NM_CONTROLLED="yes"
ONBOOT="yes"
BOOTPROTO="none"
IPADDR=192.168.1.11
NETMASK=255.255.255.0
GATEWAY=192.168.1.1
#+end_example
- *Step 3* » Now open =/etc/sysconfig/dhcpd= file and add the preferred interface name to DHCPDARGS variable as below
#+begin_example
# Command line options here
DHCPDARGS=eth0
#+end_example
- *Step 4* » open =/etc/dhcp/dhcpd.conf= file and paste the below lines and save it.
#+begin_example
#specify domain name
option domain-name "krizna.com";
#specify DNS server ip and additional DNS server ip
option domain-name-servers 192.168.1.10, 208.67.222.222;
#specify default lease time
default-lease-time 600;
#specify Max lease time
max-lease-time 7200;
#specify log method
log-facility local7;
#Configuring subnet and iprange
subnet 192.168.1.0 netmask 255.255.255.0 {
range 192.168.1.50 192.168.1.254;
option broadcast-address 192.168.1.255;
#Default gateway ip
option routers 192.168.1.1;
}
#Fixed ip address based on MAC id
host Printer01 {
hardware ethernet 02:34:37:24:c0:a5;
fixed-address 192.168.1.55;
}
#+end_example
- *Step 5* » Now start the service
#+begin_example
[root@localhost ~]# service dhcpd start
#+end_example
- and type this below command to start dhcp service automatically while booting.
#+begin_example
[root@localhost ~]# chkconfig --levels 235 dhcpd on
#+end_example
- That’s it .Clients can get IP from DHCP server and Please ensure you don’t have any other dhcp servers in the same network ( Routers might have DHCP enabled ).

* 2016-March-30-wednesday:
** From 9:30 AM TO 06:00 PM :
- Today I have practised bridge network, connected couple of containers interfaces and bridge, Setting Up Bridge for Private Network.
  And I have completed various articles from online which is available at [[https://github.com/vlead/ovpl/blob/master/docs/bridge-setup.org][here]]
* Setting Up Bridge for Private Network
** Creating a bridge: 
- Bridge is basically a file configured with essential settings which mentions the bridge name, boot protocol, on boot settings, type and if it is to be network manager controlled. Move to the network-scripts directory in /etc/sysconfig by following command:
#+begin_example
cd /etc/sysconfig/network-scripts/
#+end_example
- We next step set up a bridge in our private network. Let us call it as br1. To create the bridge, create a file with name ifcfg-br1 in the current directory including the following settings:
#+begin_example
DEVICE=br1
TYPE=Bridge
ONBOOT=yes
NM_CONTROLLED=no
BOOTPROTO=none
#+end_example
 * Restart network service to effect the changes.
#+begin_example
service network restrat
#+end_example
 * Following command can be issued to list all the bridges created and the interfaces they are connected to.
#+begin_example
brctl show
#+end_example
- The output has to contain the created bridge and any other bridges previously created with connected interfaces.
  With current configuration used, a sample output can be seen below:
#+begin_example
bridge name	bridge id		STP enabled	interfaces
br1		8000.000000000000	no	         
#+end_example
** Creating private subnet:
- To test the settings we can create our own private subnet with three test containers.
#+begin_example
vzctl create 101 --ostemplate centos-6-x86_64 --hostname centos-1
vzctl create 102 --ostemplate centos-6-x86_64 --hostname centos-2
vzctl create 103 --ostemplate centos-6-x86_64 --hostname centos-3
#+end_example
- Note that ip address is not set for creating the containers.
- set the netfilter to full for the containers.
#+begin_example
vzctl set 101 --netfilter full --save
vzctl set 102 --netfilter full --save
vzctl set 103 --netfilter full --save
#+end_example
- The containers needs to be connected to the bridge br0.This is achieved by connecting with the respective interfaces. This is done by the following commands:
#+begin_example
vzctl set 101 --netif_add eth0,,,,br1 --save
vzctl set 102 --netif_add eth1,,,,br1 --save
vzctl set 103 --netif_add eth2,,,,br1 --save
#+end_example
- Start the containers and set its status to running.
#+begin_example
vzctl start 101
vzctl start 102
vzctl start 103
#+end_example
* Configuring Containers:
- Enter the contianers
#+begin_example
vzctl enter 101
vzctl enter 102
vzctl enter 103
#+end_example
- eth0,eth1 and eth2 interfaces of the containers needs to be configured to connect to the bridge. The configuration can set in the directory network-scripts for the files ifcfg-eth0, ifcfg-eth1 and ifcfg-eth2.
#+begin_example
cd /etc/sysconfig/network-scripts
#+end_example
 * ifcfg-eth0 file should contain the following settings:
#+begin_example
DEVICE=eth0
HWADDR=00:18:51:9A:D8:E5
BOOTPROTO=static
ONBOOT=yes
NM_CONTROLLED=no
IPADDR=10.2.59.101
NETMASK=255.255.255.0
#+end_example
 * ifcfg-eth1 file should contain the following settings:
#+begin_example
DEVICE=eth1
HWADDR=00:18:51:97:0D:0C
BOOTPROTO=static
ONBOOT=yes
NM_CONTROLLED=no
IPADDR=10.2.59.102
NETMASK=255.255.255.0
#+end_example
 * ifcfg-eth2 file should contain the following settings:
#+begin_example
DEVICE=eth2
HWADDR=00:18:51:86:A8:F3
BOOTPROTO=static
ONBOOT=yes
NM_CONTROLLED=no
IPADDR=10.2.59.103
NETMASK=255.255.255.0
#+end_example
- Restart the network service and check if the eth0, eth1 and eth2 are assigned to ip-address or not (ifconfig command).
- The hardware address can be known by the command ifconfig -a.
- *Note*: Hardware address will be only available after adding the configuration files. The process is to first add the configuration without the hardware address,
  restart the service and later update it.

* 2016-March-31-Thursday:
** From 9:30 AM TO 06:00 PM :
- Today I started Python Programming Language and basics of Programming Language concepts. And I read various articles from online.
* What is Python?:
 - Python is an interpreted, interactive object-oriented programming language suitable (amongst other uses) for distributed application development, scripting, numeric computing and system testing.
 - Python is often compared to Tcl, Perl, Java, JavaScript, Visual Basic or Scheme.
** Features of Python:
 + A variety of basic data types are available: numbers (floating point, complex, and unlimited-length long integers), strings (both ASCII and Unicode), lists, and dictionaries.
 + Python supports object-oriented programming with classes and multiple inheritance.
 + Code can be grouped into modules and packages.
 + The language supports raising and catching exceptions, resulting in cleaner error handling.
 + Data types are strongly and dynamically typed. Mixing incompatible types (e.g. attempting to add a string and a number) causes an exception to be raised, so errors are caught sooner.
 + Python contains advanced programming features such as generators and list comprehensions.
 + Python's automatic memory management frees you from having to manually allocate and free memory in your code.
* Why should you learn to write programs?
- Writing programs (or programming) is a very creative and rewarding activity. You can write programs for many reasons, ranging from making your living to solving a difficult, data analysis problem to having fun to helping someone else solve a problem. 
* What is Program?:
- The definition of a program at its most basic is a sequence of Python statements, that have been crafted to do something. Even our simple hello.py script is a pro-
  gram. It is a one-line program and is not particularly useful, but in the strictest definition, it is a Python program. It might be easiest to understand what a program is by thinking about a problem that a program might be built to solve,
  and then looking at a program that would solve that problem.
** Program:
- A set of instructions that specifies a computation.
** Programming:
- The act of writing instructions to the CPU down and getting instructions to be correct 
** Programmer:
- Skilled in the art of programming	
* Word and Sentences:
- The Python vocabulary is actually pretty small. We call this “vocabulary” the “reserved words”. These are words that have very special meaning to Python. When Python sees these words in a Python program, they
  have one and only one meaning to Python. Later as you write programs you will make up your own words that have meaning to you called variables. 
#+begin_example
print 'Hello world!'
#+end_example
+ And we have even written our first syntactically correct Python sentence. Our sentence starts with the reserved word print followed by a string of text of our choosing enclosed in single quotes.
** Python vocabulary:
- Reserved words; words that have one meaning to python	
** Variables:
- Make up words that have meaning to you; cannot use reserved words	
** Script:
- A text editor that we write the python instructions into a file, ends with .py	
** Semantics:
- The meaning of a program.
* Terminology: interpreter and compiler:
- Python is a high-level language intended to be relatively straightforward for hu-mans to read and write and for computers to read and process. Other high-level
  languages include Java, C++, PHP, Ruby, Basic, Perl, JavaScript, and many more. The actual hardware inside the Central Processing Unit (CPU) does not understand
  any of these high-level languages. The CPU understands a language we call machine language. Machine language is very simple and frankly very tiresome to write because it is represented all in
  zeros and ones:
#+begin_example
01010001110100100101010000001111
11100110000011101010010101101101
#+end_example
** Compile:
- To translate a program written in a high-level language into a low-level language all at once, in preparation for later execution.
** Interpreter:
- Reads the source code of the program as written by the programmer, parses the source code, and interprets the instructions on the fly, example is python
- To execute a program in a high-level language by translating it one line at a time.
#+begin_example
>>> x = 6
>>> print x
6
>>> y = x * 6
>>> print y
36
>>>
#+end_example
** High-Level Language:
- A programming language like Python, that is designed to be easy for humans to read and write.
** Low-level Language:
- A programming language that is designed to be easy for a computer to execute; also called “machine code” or “assembly language”.
** Machine Code:
- The lowest-level language for software, which is the language, that is directly executed by the central processing unit (CPU).
** Interactive mode:
- A way of using the Python interpreter by typing commands and expressions at the prompt.
* The building blocks of programs:
- We will learn more about the vocabulary, sentence struc-ture, paragraph structure, and story structure of Python. We will learn about the powerful capabilities of Python and how to compose those capabilities together to create useful programs.
- There are some low-level conceptual patterns that we use to construct programs. These constructs are not just for Python programs, they are part of every program- ming language from machine language up to the high-level languages.
** Input:
- Get data from the "outside world". examples include reading data from a file	
** Output:	
- Display the results of the program on a screen or store them in a file
** Sequential execution:
- Perform statements one after another in the order they are encountered in the script	
** Conditional execution:
- Check for certain conditions and then execute or skip a sequence of statements	
** Repeated execution	
- Perform some set of statements repeatedly, usually with some variation	
** Reuse:
- Write a set of instructions once, give them a name, and then reuse those instructions as needed throughout your program	
* What could possibly go wrong?:
- As we saw in our earliest conversations with Python, we must communicate very precisely when we write Python code. The smallest deviation or mistake will cause Python to give up looking at your program. Beginning programmers often take the fact that Python leaves no room for errors as evidence that Python is mean, hateful, and cruel.
  While Python seems to like everyone else, Python knows them personally and holds a grudge against them. Because of this grudge, Python takes our perfectly written programs and rejects
  them as “unfit” just to torment us.
#+begin_example
>>> primt 'Hello world!'
File "<stdin>", line 1
primt 'Hello world!'
ˆ
SyntaxError: invalid syntax
>>> primt 'Hello world'
File "<stdin>", line 1
primt 'Hello world'
ˆ
SyntaxError: invalid syntax
>>> I hate you Python!
File "<stdin>", line 1
I hate you Python!
ˆ
SyntaxError: invalid syntax
>>> if you come out of there, I would teach you a lesson
File "<stdin>", line 1
if you come out of there, I would teach you a lesson
ˆ
SyntaxError: invalid syntax
>>>
#+end_example
** Bug:
- An error in a program.
** Syntax Error:
- violated the "grammar rules of python	
** Logic Errors	
- The program has good syntax but there is a mistake in the order of the statements or perhaps in how the statements relate to one another	
** Semantic Errors:
- An error in a program that makes it do something other than what the programmer intended.
** Parse:
- To examine a program and analyze the syntactic structure.
** Portability:
- A property of a program that can run on more than one kind of computer.
** Print Statement:
- An instruction that causes the Python interpreter to display a value on the screen.
** Problem Solving:
- The process of formulating a problem, finding a solution, and expressing the solution.
** Prompt:
- When a program displays a message and pauses for the user to type some input to the program.
** Source code:
- A program in a high-level language.

* Varibale, Expressions and Statements:
** Values and types:
- A value is one of the basic things a program works with, like a letter or a number. The values we have seen so far are 1, 2, and 'Hello, World!'
- These values belong to different types: 2 is an integer, and 'Hello, World!' is a string, so called because it contains a “string” of letters. You (and the interpreter)
  can identify strings because they are enclosed in quotation marks.
- The print statement also works for integers. We use the python command to start the interpreter.
#+begin_example
python
>>> print 4
4
#+end_example
- If you are not sure what type a value has, the interpreter can tell you.
#+begin_example
>>> type('Hello, World!')
<type 'str'>
>>> type(17)
<type 'int'>
>>> type(3.2)
<type 'float'>
#+end_example
** Variables:
- A variable is a name that refers to a value.
- An assignment statement creates new variables and gives them values:
#+begin_example
>>> message = 'Hello Welcome To Python Programming Language'
>>> n = 17
>>> pi = 3.1415926535897931
#+end_example
- This example makes three assignments. The first assigns a string to a new vari-able named message; the second assigns the integer 17 to n; the third assigns the
  (approximate) value of π to pi.
- To display the value of a variable, you can use a print statement:
#+begin_example
>>> print n
17
>>> print pi
3.14159265359
#+end_example
- The type of a variable is the type of the value it refers to.
#+begin_example
>>> type(message)
<type 'str'>
>>> type(n)
<type 'int'>
>>> type(pi)
<type 'float'>
#+end_example
** Variable names and keywords:
- Programmers generally choose names for their variables that are meaningful and document what the variable is used for.
- Variable names can be arbitrarily long. They can contain both letters and numbers, but they cannot start with a number. It is legal to use uppercase letters, but it is a
  good idea to begin variable names with a lowercase letter (you’ll see why later).
+ Python reserves 31 keywords1 for its use:
#+begin_example
and as assert break class continue
def del elif else except exec
finally for from global if import
in is lambda not or pass print
raise return try while with yield
#+end_example
** Statements:
- A statement is a unit of code that the Python interpreter can execute. We have seen two kinds of statements: print and assignment.
- When you type a statement in interactive mode, the interpreter executes it and displays the result, if there is one.
- A script usually contains a sequence of statements. If there is more than one statement, the results appear one at a time as the statements execute.
- For example, the script
#+begin_example
print 1
x = 2
print x
#+end_example
+ produces the output
#+begin_example
1
2
#+end_example
** Operators and operands:
- Operators are special symbols that represent computations like addition and mul-tiplication. The values the operator is applied to are called operands.
- The operators +, -, *, /, and ** perform addition, subtraction, multiplication, division, and exponentiation, as in the following examples:
#+begin_example
20+32 hour-1 hour*60+minute minute/60 5**2 (5+9)*(15-7)
#+end_example
+ The division operator might not do what you expect:
#+begin_example
>>> minute = 59
>>> minute/60
0
#+end_example
** Expressions:
- An expression is a combination of values, variables, and operators. A value all by itself is considered an expression, and so is a variable, so the following are all
  legal expressions (assuming that the variable x has been assigned a value):
#+begin_example
17
x
x + 17
#+end_example
+ If you type an expression in interactive mode, the interpreter evaluates it and
  displays the result:
#+begin_example
>>> 1 + 1
2
#+end_example
** Order of operations:
- When more than one operator appears in an expression, the order of evaluation
  depends on the rules of precedence. For mathematical operators, Python follows
  mathematical convention. The acronym *PEMDAS* is a useful way to remember
  the rules:
 + *Parentheses* have the highest precedence and can be used to force an expres-
   sion to evaluate in the order you want. Since expressions in parentheses are
   evaluated first, 2 * (3-1) is 4, and (1+1)**(5-2) is 8. You can also use
   parentheses to make an expression easier to read, as in (minute * 100) /
   60, even if it doesn’t change the result.
 + *Exponentiation* has the next highest precedence, so 2**1+1 is 3, not 4, and
   3*1**3 is 3, not 27.
 + *Multiplication* and *Division* have the same precedence, which is higher than
   *Addition* and *Subtraction*, which also have the same precedence. So 2*3-1
   is 5, not 4, and 6+4/2 is 8, not 5.
 + Operators with the same precedence are evaluated from left to right. So the
   expression 5-3-1 is 1, not 3, because the 5-3 happens first and then 1 is
   subtracted from 2.
** Modulus operator:
- The modulus operator works on integers and yields the remainder when the first operand is divided by the second. In Python, the modulus operator is a percent
  sign (%). The syntax is the same as for other operators:
#+begin_example
>>> quotient = 7 / 3
>>> print quotient
2
>>> remainder = 7 % 3
>>> print remainder
1
#+end_example
** String operations:
- The + operator works with strings, but it is not addition in the mathematical sense. Instead it performs concatenation, which means joining the strings by linking
  them end to end. For example:
#+begin_example
>>> first = 10
>>> second = 15
>>> print first+second
25
>>> first = '100'
>>> second = '150'
>>> print first + second
100150
#+end_example
** Asking the user for input:
- Sometimes we would like to take the value for a variable from the user via their keyboard. Python provides a built-in function called raw_input that gets
  input from the keyboard. When this function is called, the program stops and waits for the user to type something. When the user presses Return or Enter, 
  the program resumes and raw_input returns what the user typed as a string.
#+begin_example
>>> input = raw_input()
My name is Raghu
>>> print input
My name is Raghu
#+end_example
+ Before getting input from the user, it is a good idea to print a prompt telling the user what to input. You can pass a string to raw_input to be displayed to the user
  before pausing for input:
#+begin_example
>>> name = raw_input('What is your name?\n')
What is your name?
Raghu
>>> print name
Raghu
#+end_example
+ The sequence \n at the end of the prompt represents a newline, which is a special character that causes a line break. That’s why the user’s input appears below the prompt.
+ If you expect the user to type an integer, you can try to convert the return value to int using the int() function:
#+begin_example
>>> prompt = 'What...is the airspeed velocity of an unladen swallow?\n'
>>> speed = raw_input(prompt)
What...is the airspeed velocity of an unladen swallow?
17
>>> int(speed)
17
>>> int(speed) + 5
22
#+end_example
 + But if the user types something other than a string of digits, you get an error:
#+begin_example
>>> speed = raw_input(prompt)
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
>>> int(speed)
ValueError: invalid literal for int()
#+end_example
+ We will see how to handle this kind of error later.
** comment:
- Information in a program that is meant for other programmers (or any-one reading the source code) and has no effect on the execution of the pro-gram.
#+begin_example
# compute the percentage of the hour that has elapsed
percentage = (minute * 100) / 60
#+end_example
** Choosing mnemonic variable names:
- As long as you follow the simple rules of variable naming, and avoid reserved words, you have a lot of choice when you name your variables. In the beginning,
  this choice can be confusing both when you read a program and when you write your own programs. For example, the following three programs are identical in
  terms of what they accomplish, but very different when you read them and try to understand them.
#+begin_example
a = 35.0
b = 12.50
c = a * b
print c

hours = 35.0
rate = 12.50
pay = hours * rate
print pay

x1q3z9ahd = 35.0
x1q3z9afd = 12.50
x1q3p9afd = x1q3z9ahd * x1q3z9afd
print x1q3p9afd
#+end_example

* Conditinal Execution
** Boolean Expressions:
- A boolean expression is an expression that is either true or false. The following examples use the operator ==, which compares two operands and produces True
  if they are equal and False otherwise
#+begin_example
>>> 5 == 5
True
>>> 5 == 6
False
#+end_example
+True and False are special values that belong to the type bool; they are not strings:
#+begin_example
>>> type(True)
<type 'bool'>
>>> type(False)
<type 'bool'>
#+end_example
- The == operator is one of the comparison operators; the others are:
#+begin_example
x != y # x is not equal to y
x > y  # x is greater than y
x < y  # x is less than y
x >= y # x is greate than or equal to y
x <= y # x is less than or equal to y
x is y # x is the same as y
x is not y # x is the same as y
#+end_example
- Although these operations are probably familiar to you, the Python symbols are different from the mathematical symbols for the same operations. A common error
  is to use a single equal sign (=) instead of a double equal sign (==). Remember that = is an assignment operator and == is a comparison operator. There is no such thing as =< or =>.
** Logical Operators:
- There are three logical operators: and, or, and not. The semantics (meaning) of these operators is similar to their meaning in English. For example,
#+begin_example
x > 0 and x < 10
#+end_example
is true only if x is greater than 0 and less than 10.
#+begin_example
n%2 == 0 or n%3 == 0
#+end_example
is true if either of the conditions is true, that is, if the number is divisible by 2 or 3.
Finally, the not operator negates a boolean expression, so not (x > y) is true if x > y is false; that is, if x is less than or equal to y.
Strictly speaking, the operands of the logical operators should be boolean expres-
sions, but Python is not very strict. Any nonzero number is interpreted as “true.”
#+begin_example
>>> 17 and True
True
#+end_example
This flexibility can be useful, but there are some subtleties to it that might be confusing. You might want to avoid it until you are sure you know what you are doing.

** Conditional Execution:
- In order to write useful programs, we almost always need the ability to check con-ditions and change the behavior of the program accordingly. Conditional state-ments give us this ability. The simplest form is the if statement:
#+begin_example
if x > 0 :
print 'x is positive'
#+end_example
- The boolean expression after the if statement is called the condition. We end thef statement with a colon character (:) and the line(s) after the if statement are indented.
- If you enter an if statement in the Python interpreter, the prompt will change from three chevrons to three dots to indicate you are in the middle of a block of statements, as shown below:
#+begin_example
>>> x = 3
>>> if x < 10:
...
print 'Small'
...
Small
>>>
#+end_example
** Alternative Execution:
- A second form of the if statement is alternative execution, in which there are two possibilities and the condition determines which one gets executed. The syntax looks like this:
#+begin_example
if x%2 == 0 :
print 'x is even'
else :
print 'x is odd'
#+end_example
- If the remainder when x is divided by 2 is 0, then we know that x is even, and the program displays a message to that effect. If the condition is false, the second set of statements is executed.
- Since the condition must either be true or false, exactly one of the alternatives will be executed. The alternatives are called branches, because they are branches in the flow of execution.
** Chained conditionals:
- Sometimes there are more than two possibilities and we need more than two branches. One way to express a computation like that is a chained conditional:
#+begin_example
if x < y:
print 'x is less than y'
elif x > y:
print 'x is greater than y'
else:
print 'x and y are equal'
#+end_example
- elif is an abbreviation of “else if.” Again, exactly one branch will be executed.
- There is no limit on the number of elif statements. If there is an else clause, it has to be at the end, but there doesn’t have to be one.
#+begin_example
if choice == 'a':
print 'Bad guess'
elif choice == 'b':
print 'Good guess'
elif choice == 'c':
print 'Close, but not correct'
#+end_example
- Each condition is checked in order. If the first is false, the next is checked, and so on. If one of them is true, the corresponding branch executes, and the statement
  ends. Even if more than one condition is true, only the first true branch executes.
** Nested conditionals:
- One conditional can also be nested within another. We could have written the three-branch example like this:
#+begin_example
if x == y:
print 'x and y are equal'
else:
if x < y:
print 'x is less than y'
else:
print 'x is greater than y'
#+end_example
- The outer conditional contains two branches. The first branch contains a sim-ple statement. The second branch contains another if statement, which has two branches of its own.
  Those two branches are both simple statements, although they could have been conditional statements as well.
- Although the indentation of the statements makes the structure apparent, nested conditionals become difficult to read very quickly. In general, it is a good idea to
  avoid them when you can.
- Logical operators often provide a way to simplify nested conditional statements.
+ For example, we can rewrite the following code using a single conditional:
#+begin_example
if 0 < x:
if x < 10:
print 'x is a positive single-digit number.'
#+end_example
- The print statement is executed only if we make it past both conditionals, so we can get the same effect with the and operator:
#+begin_example
if 0 < x and x < 10:
print 'x is a positive single-digit number.'
#+end_example

** Short-circuit evaluation of logical expressions:
- When Python is processing a logical expression such as x >= 2 and (x/y) >2, it evaluates the expression from left to right. Because of the definition of and,
  if x is less than 2, the expression x >= 2 is False and so the whole expression is False regardless of whether (x/y) > 2 evaluates to True or False.
- When Python detects that there is nothing to be gained by evaluating the rest of a logical expression, it stops its evaluation and does not do the computations in
  the rest of the logical expression. When the evaluation of a logical expression stops because the overall value is already known, it is called short-circuiting the evaluation.
- While this may seem like a fine point, the short-circuit behavior leads to a clever technique called the guardian pattern. Consider the following code sequence in the Python interpreter:
#+begin_example
>>> x = 6
>>> y = 2
>>> x >= 2 and (x/y) > 2
True
>>> x = 1
>>> y = 0
>>> x >= 2 and (x/y) > 2
False
>>> x = 6
>>> y = 0
>>> x >= 2 and (x/y) > 2
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero
>>>
#+end_example
- The third calculation failed because Python was evaluating (x/y) and y was zero,which causes a runtime error. But the second example did not fail because the first part of the expression x >= 2 evaluated to False so,
  the (x/y) was not ever executed due to the short-circuit rule and there was no error.
- We can construct the logical expression to strategically place a guard evaluation just before the evaluation that might cause an error as follows:
#+begin_example
>>> x = 1
>>> y = 0
>>> x >= 2 and y != 0 and (x/y) > 2
False
>>> x = 6
>>> y = 0
>>> x >= 2 and y != 0 and (x/y) > 2
False
>>> x >= 2 and (x/y) > 2 and y != 0
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero
>>>
#+end_example
- In the first logical expression, x >= 2 is False so the evaluation stops at the and. In the second logical expression, x >= 2 is True but y != 0 is False so we never reach (x/y).
- In the third logical expression, the y != 0 is after the (x/y) calculation so the expression fails with an error.
- In the second expression, we say that y != 0 acts as a guard to insure that we only execute (x/y) if y is non-zero.

* Functions
** Function calls:
- In the context of programming, a function is a named sequence of statements, that performs a computation. When you define a function, you specify the name and the sequence of statements. Later, you can “call” the function by name. We have
  already seen one example of a function call:
#+begin_example
>>> type(32)
<type 'int'>
#+end_example
- The name of the function is type. The expression in parentheses is called the argument of the function. The argument is a value or variable, that we are passing into the function as input to the function.
  The result, for the type function, is the type of the argument.
- It is common to say that a function “takes” an argument and “returns” a result. The result is called the return value.
** Why functions?
- It may not be clear why it is worth the trouble to divide a program into functions. There are several reasons:
+ Creating a new function gives you an opportunity to name a group of state-ments, which makes your program easier to read, understand, and debug.
+ Functions can make a program smaller by eliminating repetitive code. Later, if you make a change, you only have to make it in one place.
+ Dividing a long program into functions allows you to debug the parts one at a time and then assemble them into a working whole.
+ Well-designed functions are often useful for many programs. Once you write and debug one, you can reuse it.
** Built-in functions:
- Python provides a number of important built-in functions that we can use without needing to provide the function definition. The creators of Python wrote a set of
  functions to solve common problems and included them in Python for us to use.
- The max and min functions give us the largest and smallest values in a list, respec-tively:
#+begin_example
>>> max('Hello world')
'w'
>>> min('Hello world')
' '
>>>
#+end_example
- The max function tells us the “largest character” in the string (which turns out to be the letter “w”) and the min function shows us the smallest character (which turns out to be a space).
- Another very common built-in function is the len function which tells us how many items are in its argument. If the argument to len is a string, it returns the number of characters in the string.
#+begin_example
>>> len('Hello world')
11
>>>
#+end_example
- These functions are not limited to looking at strings. They can operate on any set of values, as we will see in later chapters.
- You should treat the names of built-in functions as reserved words (i.e., avoid using “max” as a variable name).
** Type conversion functions:
- Python also provides built-in functions that convert values from one type to an-other. The int function takes any value and converts it to an integer, if it can, or complains otherwise:
#+begin_example
>>> int('32')
32
>>> int('Hello')
ValueError: invalid literal for int(): Hello
#+end_example
- int can convert floating-point values to integers, but it doesn’t round off; it chops off the fraction part:
#+begin_example
>>> int(3.99999)
3
>>> int(-2.3)
-2
#+end_example
- float converts integers and strings to floating-point numbers:
#+begin_example
>>> float(32)
32.0
>>> float('3.14159')
3.14159
#+end_example
- Finally, str converts its argument to a string:
#+begin_example
>>> str(32)
'32'
>>> str(3.14159)
'3.14159'
#+end_example

** Parameters and arguments:
 - The arguments are assigned to variables called parameters. Here is an example of a user-defined function that takes an argument:
#+begin_example
def apple(fruit):
    print fruit
apple("red")
#+end_example
- This function assigns the argument to a parameter named fruit. When the func-tion is called, it prints the value of the parameter.

* 2016-Apr-01-Friday:
** From 9:30 AM TO 06:00 PM :
- I have practised Python Programs and wrote a simple python script that will Variables, Expressions, Functions and Conditional statements. This script will also check status of programs.
- Executed the script using command
#+begin_example
chmod +x filename.py
./script.py 
#+end_example
 * Script has the following code:

# To findout the Variables and Expressions
message = "Welcome to my first python script"
firstname = "raghupathi"
lastname = " kammari"
age = 23
sex = "male"
city = "hyd"
print message
print firstname+lastname
print age 
print sex
print city

# The program stops and waits for the user to type something.
input = raw_input()
print input

# built in function for getting input from the user
name = raw_input('what is your name?\n')
print name

# To find the below variables using mnemonic variable names
a = "raghu"
b = "pathi"
c = a+b
print c

# To check below given values are True or False using Boolean Expressins
5 == 5
5 == 6

# To find the biggest and smallest number using Conditional Execution
x = 5
if x > 0 : print 'x is possitive'
y = 0
if y < 5 : print 'y is negatibe'
# To check whether even or odd number using Alternative Execution
x = 10
if x % 2 == 0 : print 'x is even'
else : print 'x is odd'
# To find the biggest and smallest number using Chained Conditionals
x = 10
y = 20
if x == y : print 'x and y are equal'
elif x > y : print 'x is greater than y'
else : print 'x is less than y'

# To print Prime numbers from 1 to 11
for num in range(1,11):
    prime = True
    for i in range(2,num):
        if (num%i==0):
            prime = False
    if prime:
       print num

# This Function is to camputation of math values and the arguments provide while function call.
def square(a,b):
    print a*a
    print b*b
    print a+b
square(2,3)
# Function call to raghu and function names with following arguments
def raghu():
    print "Hello World"
raghu()

x = "raghupathi"
y = " kammari"
def f():
    return x + y
print f()

def power(base,exponent):
 result = base ** exponent
 print "%d to the power of %d is %d." % (base,exponent,result)
power(4,2)

# To check whether the even or odd numbers using the arguments provide while function call.
def even(x):
    if x % 2 == 0 :
        return "10 is a even number"
    else :
        return "10 is a odd number"
print even(10)

